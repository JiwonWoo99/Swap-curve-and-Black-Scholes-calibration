# -*- coding: utf-8 -*-
"""Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nejhjEOHYirTw1DMy505re1j9T7xB0LH

# Curve
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# 현재 날짜 설정
current_date = datetime(2024, 4, 29)

# 기존 데이터 입력
data = pd.DataFrame({
    'Period': ['1BD', '3M', '6M', '9M', '12M', '15M', '18M', '21M', '24M', '27M', '30M', '33M', '36M', '39M', '42M', '45M', '48M', '51M', '54M', '57M', '60M', '84M', '120M', '144M', '180M', '240M'],
    'Quote': [0.0212, 0.0214, 0.03585, 0.035925, 0.036, np.nan, np.nan, np.nan, 0.0355, np.nan, np.nan, np.nan, 0.035175, np.nan, np.nan, np.nan, 0.035175, np.nan, np.nan, np.nan, 0.035125,
              0.03515, 0.0352, 0.0353, 0.035275, 0.0339]
})

# 5Y 이후부터 20Y까지 3개월 단위 기간 추가
new_periods = [f"{3 * n}M" for n in range(21, 81)]  # 63M to 240M (20Y)

additional_periods = [{'Period': period, 'Quote': np.nan} for period in new_periods if period not in data['Period'].values]
additional_data = pd.DataFrame(additional_periods)

# 데이터 병합
curve = pd.concat([data, additional_data], ignore_index=True)

# Period 문자열을 월 단위로 변환하는 함수
def period_to_months(period):
    if period.endswith('BD'):
        return 1 / 30
    elif period.endswith('M'):
        return int(period[:-1])
    elif period.endswith('Y'):
        return int(period[:-1]) * 12
    else:
        return 0

curve['Months'] = curve['Period'].apply(period_to_months)
curve = curve.sort_values(by='Months').reset_index(drop=True)
curve = curve.drop(columns='Months')

# 데이터 보간
curve['Quote'].interpolate(method='linear', inplace=True)

# 필요한 열
curve['PV'] = np.nan
curve['FV'] = np.nan
curve['DF'] = np.nan
curve['Forward'] = np.nan
curve['Spot'] = np.nan
curve['Maturity'] = pd.NaT

# 1BD 계산
curve.loc[curve['Period'] == '1BD', 'DF'] = np.exp(-curve.loc[curve['Period'] == '1BD', 'Quote'] * 1 / 360)
curve.loc[curve['Period'] == '1BD', 'Maturity'] = current_date + timedelta(days=1)

# 모든 기간에 대한 FV, PV, DF 계산 및 만기일 계산
for i in range(1, len(curve)):
    Quote_current = curve.loc[i, 'Quote']

    # FV 계산
    curve.loc[i, 'FV'] = 100 + 100 * Quote_current * 90 / 360   # 30/360

    # PV 계산: 모든 이전 기간의 DF를 사용
    if i == 1:  # 3M 경우, 예외로 100 고정
        curve.loc[i, 'PV'] = 100
    else:
        pv = 100
        for j in range(1, i):
            pv -= 100 * curve.loc[i, 'Quote'] * 90 / 360 * curve.loc[j, 'DF']
        curve.loc[i, 'PV'] = pv

    # DF 계산
    curve.loc[i, 'DF'] = curve.loc[i, 'PV'] / curve.loc[i, 'FV']

    # 만기일 계산
    months = period_to_months(curve.loc[i, 'Period'])
    maturity_date = current_date + timedelta(days=int(months * 30))
    curve.loc[i, 'Maturity'] = maturity_date

# Forward 계산
for i in range(1, len(curve)):
    start_day = period_to_months(curve.loc[i - 1, 'Period']) * 30
    end_day = period_to_months(curve.loc[i, 'Period']) * 30

    if i == 1:
        day_diff = 89
    else:
        day_diff = end_day - start_day

    curve.loc[i - 1, 'Forward'] = (curve.loc[i - 1, 'DF'] / curve.loc[i, 'DF'] - 1) * (360 / day_diff)
    #print(i, curve.loc[i - 1, 'DF'], curve.loc[i, 'DF'],day_diff,curve.loc[i - 1, 'Forward'])

# Spot 계산
for i in range(len(curve)):
    days = period_to_months(curve.loc[i, 'Period']) * 30
    curve.loc[i, 'Spot'] = -np.log(curve.loc[i, 'DF']) / (days / 360)

# 만기일 계산
def calculate_maturity(start_date, months):
    year = start_date.year
    month = start_date.month
    day = start_date.day

    month += months
    while month > 12:
        month -= 12
        year += 1

    # 30/360
    if day > 30:
        day = 30

    return datetime(year, month, day)

for i in range(len(curve)):
    months = period_to_months(curve.loc[i, 'Period'])
    curve.loc[i, 'Maturity'] = calculate_maturity(current_date, int(months))

curve['Maturity'] = curve['Maturity'].dt.strftime('%Y-%m-%d')
curve['Maturity'] = pd.to_datetime(curve['Maturity'])

curve[['Period', 'Maturity', 'Quote', 'PV', 'FV', 'DF', 'Spot', 'Forward']]

# Forward rate을 계산하는 함수
def get_forward_rate_for_date(target_date_str):
    target_date = datetime.strptime(target_date_str, '%Y-%m-%d')

    # 해당 날짜와 가장 가까운 이전 기간과 이후 기간 찾기
    previous_period = curve[curve['Maturity'] <= target_date].iloc[-1]
    next_period = curve[curve['Maturity'] > target_date].iloc[0]

    # DF와 잔존일자 계산
    df_previous = previous_period['DF']
    df_next = next_period['DF']
    start_day = (target_date - current_date).days
    end_day_previous = (previous_period['Maturity'] - current_date).days
    end_day_next = (next_period['Maturity'] - current_date).days

    # 선형 보간을 통해 해당 날짜의 DF 계산
    df_target = df_previous + (df_next - df_previous) * (start_day - end_day_previous) / (end_day_next - end_day_previous)

    # 해당 날짜에 대한 Forward 금리 계산
    forward_rate = (df_previous / df_target - 1) * (360 / (start_day - end_day_previous))

    return forward_rate

import matplotlib.pyplot as plt

plt.figure(figsize=(14, 8))

plt.plot(curve['Maturity'], curve['Spot'], label='Spot Rate')

plt.plot(curve['Maturity'], curve['Forward'], label='Forward Rate')

plt.xlabel('Maturity')
plt.ylabel('Rate')
plt.title('Spot Rate, and Forward Rate')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

plt.show()

"""# Volatility Surface"""

import pandas as pd
from datetime import datetime
from scipy.stats import norm

# Market Option Data
df = pd.read_excel('Data_final.xlsx')

now_date = datetime(2024, 4, 29)
spot = 364.48

# t 계산 함수
def calculate_t(row):
    maturity_date = pd.to_datetime(row['Maturity'])
    t = (maturity_date - now_date).days / 365
    return t

df['t'] = df.apply(calculate_t, axis=1)
# risk free rate 추가
df['rf'] = df['Maturity'].dt.strftime('%Y-%m-%d').apply(get_forward_rate_for_date)

#거래량이 100보다 작은 행 제거
df = df[df['Volume'] >= 100].reset_index(drop=True)

# Implied Volatility 계산
def black_scholes_call_price(S, K, T, r, sigma):
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def implied_volatility(S, K, T, r, market_price):
    sigma = 0.2
    for i in range(100):
        price = black_scholes_call_price(S, K, T, r, sigma)
        vega = S * norm.pdf((np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))) * np.sqrt(T)
        sigma -= (price - market_price) / vega
        if abs(price - market_price) < 1e-5:
            break
    return sigma

df['IV'] = df.apply(lambda row: implied_volatility(spot, row['Strike'], row['t'], row['rf'], row['Price']), axis=1)

df

# IV_surface 데이터프레임 생성
IV_surface = df.pivot(index='Maturity', columns='Strike', values='IV')
IV_surface

# 빈 값을 채우는 함수
def fill_missing_values(row):
    for i in range(len(row)):
        if np.isnan(row.iloc[i]):
            left = row.iloc[:i][~np.isnan(row.iloc[:i])]
            right = row.iloc[i+1:][~np.isnan(row.iloc[i+1:])]
            if len(left) == 0 and len(right) > 0:
                row.iloc[i] = right.iloc[0]
            elif len(left) > 0 and len(right) == 0:
                row.iloc[i] = left.iloc[-1]
            elif len(left) > 0 and len(right) > 0:
                row.iloc[i] = (left.iloc[-1] + right.iloc[0]) / 2
    return row

IV_surface = IV_surface.apply(fill_missing_values, axis=1)

IV_surface

from mpl_toolkits.mplot3d import Axes3D

now_date = datetime(2024, 4, 29)

maturity_numeric = (IV_surface.index - now_date).days / 365.25

fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

strikes = IV_surface.columns
maturities, strikes = np.meshgrid(strikes, maturity_numeric)

Z = IV_surface.values

surf = ax.plot_surface(strikes, maturities, Z, cmap='viridis', edgecolor='none')

ax.set_xlabel('Strike')
ax.set_ylabel('Maturity (Years)')
ax.set_zlabel('Implied Volatility')
ax.set_title('Implied Volatility Surface')

fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5)

plt.show()

# 특정 Spot 가격에서 Implied Volatility 찾는 함수
def find_implied_vol(surface, spot, maturity):
    # Maturity를 숫자로 변환
    maturity_numeric = (surface.index - now_date).days / 365
    target_maturity_numeric = (maturity - now_date).days / 365

    # 가장 가까운 Maturity 찾기
    closest_maturity_idx = np.abs(maturity_numeric - target_maturity_numeric).argmin()
    closest_maturity = surface.index[closest_maturity_idx]

    # 가장 가까운 Strike 찾기
    strike_diff = abs(surface.columns - spot)
    closest_strike_idx = strike_diff.argmin()
    closest_strike = surface.columns[closest_strike_idx]

    # 해당 Maturity와 Strike에서의 Implied Volatility 반환
    return surface.loc[closest_maturity, closest_strike]

"""# Black Sholes Model Calibration"""

S = 364.48
K = 405.713596786274
T = 1
r = curve['Forward'][4]
sigma = 0.16

Price = black_scholes_call_price(S, K, T, r, sigma)
Fitted_Value = implied_volatility(S, K, T, r, Price)

maturity = datetime(2025, 4, 29)
implied_vol = find_implied_vol(IV_surface, K, maturity)
implied_vol

Error = implied_vol - Fitted_Value
Error2 = Error*Error
Relative_Error = Error/implied_vol

print( f"Error: {Error}, Relative Error: {Relative_Error}, Error^2 {Error2}")

"""# Montecarlo Simulation

"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta

#np.random.seed(123)

spot_initial = 364.48
end_date = datetime(2025, 4, 29)
frequency = timedelta(days=1)
num_paths = 1000000   # Path 개수

# 날짜 생성
now_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
num_days = (end_date - now_date).days
dates = [now_date + timedelta(days=i) for i in range(num_days + 1)]

spots = np.full((num_days + 1, num_paths), spot_initial)

# 특수한 날짜 정의
special_dates = [datetime(2024, 4, 29), datetime(2024, 7, 29), datetime(2024, 10, 29), datetime(2025, 1, 29), datetime(2025, 4, 29)]
special_rates = [curve['Forward'][i] for i in range(len(special_dates))]

# 몬테카를로 시뮬레이션
for t in range(1, num_days + 1):
    current_date = dates[t]
    previous_date = dates[t - 1]

    # 이자율과 변동성
    if current_date in special_dates:
        r = special_rates[special_dates.index(current_date)]
    else:
        r = get_forward_rate_for_date(current_date.strftime('%Y-%m-%d'))

    sigma = find_implied_vol(IV_surface, spot_initial, current_date)

    dt = (current_date - previous_date).days / 365.0

    # 각 경로에 대해 새로운 Spot 계산
    dW = np.random.normal(0, np.sqrt(dt), num_paths)
    spots[t] = spots[t - 1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * dW)

simulation_results = pd.DataFrame(spots, index=[date.strftime('%Y-%m-%d') for date in dates], columns=range(num_paths))

# 결과 출력
simulation_results.head(10)

# DCF, DF, Spot, Dividend, Forward Price 계산
results_df = pd.DataFrame(index=dates, columns=['DCF', 'DF', 'Spot', 'Dividend', 'Forward Price'])

# ACT/365
results_df['DCF'] = (results_df.index - now_date).days / 365

# DF
results_df['DF'] = [
    np.exp(-get_forward_rate_for_date(date.strftime('%Y-%m-%d')) * dcf)
    if date not in special_dates else np.exp(-curve['Forward'][special_dates.index(date)] * dcf)
    for date, dcf in zip(results_df.index, results_df['DCF'])
]

# Spot, Dividend, Forward Price
results_df['Spot'] = -np.log(results_df['DF']) / results_df['DCF']
results_df['Dividend'] = 0
results_df['Forward Price'] = spot_initial * np.exp((results_df['Spot'] - results_df['Dividend']) * results_df['DCF'])
results_df['Forward Price'][0] = 364.48

averages = simulation_results.mean(axis=1)
results_df['Average'] = averages.values
std = simulation_results.std(axis=1)
results_df['Std Dev'] = std.values

# Diff
results_df['Diff'] = results_df['Average'] - results_df['Forward Price']

results_df

